\section{Scratch 2.0}
\label{sec:scratch}

Scratch es un proyecto del Grupo Lifelong Kindergarten del MIT Media Lab.
Es utilizado por estudiantes y docentes de todo el mundo para expresar ideas mediante animaciones, juegos e interacciones facilmente programables con este entorno.

El nombre proviene de la palbra \textit{scratching} que en el mundo de la informática se refiere a reutilizar código, el cual puede ser usado de forma beneficiosa y efectiva para otros propósitos y fácilmente combinado, compartido y adaptado a nuevos escenarios, lo cual es una característica clave de Scratch.

Es la segunda versión principal actual de Scratch, siguiendo a Scratch 1.4. Cuenta con un editor y un sitio web rediseñados, y permite al usuario editar proyectos directamente desde su navegador web, así como en un editor fuera de línea.

Se lanzó oficialmente en 2013 y ha sido completamente reescrito en Adobe Flash además debido a las nuevas características y al diferente lenguaje de programación, los proyectos de Scratch 2.0 se guardan en formato .sb2.

Scratch se define por una interfaz intuitiva y de simple manejo compuesta por tres zonas claramente diferenciadas. En la zona izquierda tendremos un escenario y un selector de \textit{sprites}, en el centro encontramos las diferentes categorías de bloques que podemos utilizar y un listado de los bloques pertenecientes a la categoría seleccionada, y por último tendremos un espacio vacio en la parte derecha en la que crearemos nuestro proyecto, con el simple movimiento de arrastrar el bloque deseado.

Tendremos bloques de las siguientes categorias:
\begin{itemize}
\item \textbf{Movimiento}: Mueve objetos y cambia ángulos.	  	 	
\item \textbf{Eventos}: Contiene manejadores de eventos situado al principio de cada grupo de instrucciones.
\item \textbf{Apariencia}: Controla el aspecto visual del objeto, añade bocadillos de habla o 
pensamiento, cambia el fondo, ampliar o reducir.	 	
\item \textbf{Control}: Sentencian condicionales.
\item \textbf{Sonido}: Reproduce ficheros de audio y secuencias programables.	 	
\item \textbf{Sensore}: Los objetos pueden interactuar con el ambiente que ha creado el usuario.
\item \textbf{Lápiz}: Control del ancho, color e intensidad del lápiz.	 	
\item \textbf{Operadores} Operadores matemáticos, generador aleatorio de números, operadores booleanos.
\item \textbf{Datos}: Creación de variables y listas.	 	
\item \textbf{Mas Bloques}: Dispositivos o bloques externos creados por el usuario.
\end{itemize}

Al ser una herramienta madura y muy extendida existe una gran comunidad con la que compartir y de la que obtenter proyectos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.32]{img/scratch_IDE.png}
  	\caption{Espacio de trabajo de Scratch 2.0}
  	\label{fig:gazebo}
\end{figure}

\section{JdeRobot}
\label{sec:jderobot}

Nace de la tesis doctoral de Jose María Cañas en el año 2003 llevando desde ese momento en continua evolución y desarrollo, adaptandose a las tecnologías del momento.
Es una suite de desarrollo de software de robótica, domótica y sistemas de
visión computerizados cuya última versión, la 5.6, es la usada en este proyecto y permite la integración con ROS Kinetic. Proporciona un entorno distribuido donde las aplicaciones se forman mediante una colección de componentes asíncronos concurrentes, que se conectan mediante el middleware de comunicación ICE o mensajes ROS.
Se compone de interfaces, drivers, utilidades y aplicaciones para el desarrollo de cualquier proyecto de robótica
En este proyecto nos ayudamos de librerías como pueden ser \textit{comm, Config, JdeRobotTypes} que nos ayudan a agilizar el desarrollo de nuestra herramienta, abstraernos de ciertos niveles de complejidad y hacemos uso de una cantidad de entornos simulados en Gazebo con los que probar el correcto funcionamiento.


\section{Librería Comm}
\label{sec:libreria-com}

Librería desarrollada por JdeRobot con versiones tanto en python como en C que nos abstrae del tipo de comunicación utilizada por nuestros componentes.
Apoyandose en las librerías ya definidas en JdeRobot para el fácil uso de nodos ROS y Ice crea una capa de abstracción que permite que una aplicación sea capaz de funcionar tanto con \textit{ROS} como con comunicación \textit{Ice} sin necesidad de modificar el código interno de esta. De esta forma se aprovecha el trabajo anterior, se economiza tiempo, y se reduce el código redundante.
Su funcionamiento se apoya en el uso de un fichero de configuración necesario para establecer el tipo de comunicación que usaran los sensores y actuadores de nuestro robot. De este fichero obtendremos el tipo de comunicación y toda la información necesaria para poder establecerla. 
Se trata de un paso más en la reducción de complejidad a la hora de programar algo tan complejo como un robot.


\section{Kurt}
\label{sec:kurt}

Kurt es una biblioteca de Python que permite la manipulación compleja de proyectos de Scratch (archivos .sb y .sb2) a través de simples comandos de Python. Incluye un compilador y decompilador, que permite que un proyecto se cargue en un conjunto de objetos Python, y un compilador que permite cargar un conjunto de scripts de imágenes o texto en proyectos.
Al ser capaz de extraer toda la información contenida en un proyecto scratch, y debido al parecido en la sintaxis de scratch con python nos sirve como principal fuente de recursos a la hora, por ejemplo, de realizar una transcripción de un bloque de scratch a una sentencia python.
Se tratará con más profundidad el funcionamiento de esta librería en siguientes capítulos.


\section{Python}
\label{sec:python}
 
Python es un lenguaje de programación administrado por la Python Software Foundation. Posee una licencia de código abierto, denominada Python Software Foundation License.

Es un lenguaje interpretado, por lo que no se necesita compilar el código fuente para poder ejecutarlo, esto ofrece ventajas como la rapidez de desarrollo e inconvenientes como una menor velocidad, en ciertos casos, cuando se ejecuta por primera vez un código, se producen unos bytecodes que se guardan en el sistema y que sirven para acelerar la compilación implícita que realiza el intérprete cada vez que se ejecuta el mismo código. 

Lenguaje muy popular en los últimos años gracias a la cantidad de librerías que contiene, tipos de datos y funciones incorporadas en el propio lenguaje, que ayudan a realizar muchas tareas habituales sin necesidad de tener que programarlas desde cero, ademas cuya filosofía hace hincapié en una sintaxis que favorezca un código legible, facilitando su aprendizaje.

Su sintaxis muy visual, gracias a una notación identada (con márgenes) de obligado cumplimiento. En muchos lenguajes, para separar porciones de código, se utilizan elementos como las llaves o las palabras clave begin y end. Para separar las porciones de código en Python se debe tabular hacia dentro, colocando un margen al código que iría dentro de una función o un bucle. Esto ayuda a que todos los programadores adopten unas mismas notaciones y que los programas de cualquier persona tengan un aspecto muy similar. 

Se trata de un lenguaje de propósito general y multiplataforma, Aunque originalmente se desarrolló para Unix actualmente cualquir sistema es compatible con el lenguahe siempre y cuando exista un intérprete programado para él.

Pese a ser un lenguaje multiparadigma, principalmente está orientada a objetos lo que permite en muchos casos crear programas con componentes reutilizables. 

Tambien permite programación imperativa y programación funcional por lo que se adapta al estilo del programador y no al reves.

\section{Gazebo}
\label{sec:gazebo}
Es un simulador 3D para robots, es un proyecto de Open Source Robotics Fundation distribuido bajo la licencia Apache 2.0, con un motor de físicas y cinemáticas muy potente, es la principal herramienta en la que se apoya el desarrollador para verificar de forma segura que su implementación cumple con el objetivo determinado. Este tipo de simuladores han conseguido una fuerte evolución del mundo de la robotica ya que nos permite desarrollar componentes para dispositivos y robots complejos de forma barata y rápida.
Se trata de una herramienta altamente personalizable y moldeable que admite plugins que permiten una gestión más fina de los recursos de cara a conseguir una simulación más precisa o simplemente perimitir al desarrollador trabajar con mayor comodidad sobre el simulador.
Al ser un proyecto open source existe una comunidad muy activa detras de esta herramienta compartiendo conociemintos y publicando nuevas funcionalidades de esta.
Cabe destacar que Gazebo se compone principalmente de un cliente y un servidor. El
servidor es el encargado de realizar los calculos y la generación de los datos de los sensores,además de poder ser usado sin necesidad de una interfaz gráfica.
El cliente proporciona una interfaz grágica basada en QT que incluye la visualización de la simulación y una serie de controles de multitud de propiedades. Esta configuración permite lanzar multiples clientes sobre un servidor, consiguiendo multiples interfaces de la misma simulación.
Destacar que en 2013, este simulador se utilizó en la Virtual Robotics Challenge, un componente del DARPA Robotics Challenge.
En este proyecto Gazebo se emplea para probar la solución desarrollada en un entorno controlado para después, pasar a un entorno real.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.50]{img/gazebo.PNG}
  	\caption{Entorno de simulación Gazebo}
  	\label{fig:gazebo}
\end{figure}

\section{ROS}
\label{sec:ros}

Es un framework para el desarrollo de software para robots que provee la funcionalidad de un sistema operativo en un clúster heterogéneo. ROS (Robot Operating System) proporciona bibliotecas y herramientas para ayudar a los desarrolladores de software a crear aplicaciones de robots. Proporciona abstracción de hardware, controladores de dispositivo, bibliotecas, visualizadores, paso de mensajes, administración de paquetes y más.

 Es completamente de código abierto (BSD) y gratuito para que otros lo usen, cambien y comercialicen. SU objetivo principal es permitir que los desarrolladores de software creen aplicaciones de robots más capaces de forma rápida y fácil en una plataforma común.

ROS se desarrolló originalmente en 2007 bajo el nombre de switchyard por el Laboratorio de Inteligencia Artificial de Stanford.
 
Desde 2008, el desarrollo continua primordialmente en Willow Garage, un instituto de investigación robótico con más de veinte instituciones colaborando en un modelo de desarrollo federado

Vamos a describir a desde una perspectiva a muy alto nivel los conceptos básicos en los que se basa su arquitectura.


\subsection{Maestro ROS}
El Maestro permite que todas las demás piezas de software de ROS (Nodos) encuentren y hablen entre sí. Sin el Maestro, los nodos no podrían encontrarse, intercambiar mensajes o invocar servicios. De esta forma, no tenemos que especificar nunca específicamente "Enviar esta información del sensor a esa computadora en 127.0.0.1. Podemos simplemente decirle al Nodo 1 que envíe mensajes al Nodo 2.
El ROS Master proporciona registro y búsqueda de nombres para el resto del gráfico de computación.

BIBLIOGRAfIA

\subsection{Nodos}
Algunos robots llevan varias computadoras, cada una de las cuales controla un subconjunto de los sensores o actuadores del robot. Incluso dentro de una sola computadora, a menudo es una buena idea dividir el software del robot en pequeñas partes independientes que cooperan para lograr el objetivo general. Para esto existen los nodos de ros.
Los nodos son procesos que realizan cálculos. ROS está diseñado para ser modular en una escala de grano fino; un sistema de control de robot generalmente comprende muchos nodos.
Por ejemplo, un nodo controla un láser, un nodo controla los motores de las ruedas, un nodo proporciona una vista gráfica del sustema y así sucesivamente. Un nodo ROS se escribo con el uso de una biblioteca cliente ROS, como roscpp o rospy, más alante describiremos en detalle el proceso de desarrollo de uno un nodo ros.

\subsection{Servidor de Parámetros}
El servidor de parámetros permite que los datos se almacenen por clave en una ubicación central. Actualmente es parte del Master.

\subsection{Mensajes}
Los nodos se comunican entre sí al pasar mensajes. Un mensaje es simplemente una estructura de datos, que comprende campos tipados. Los tipos primitivos estándar (entero, punto flotante, booleano, etc.) son compatibles, al igual que las matrices de tipos primitivos. Los mensajes pueden incluir estructuras y matrices anidadas arbitrariamente (al igual que las estructuras C).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{img/ros-architecture.png}
  	\caption{Arquitectura básica ROS maestro-nodo}
  	\label{fig:ros-arch}
\end{figure}

\subsection{Topics o Temas}


Los mensajes se enrutan a través de un sistema de transporte con semántica de publicación suscripción. Un nodo envía un mensaje publicándolo en un tema determinado. El tema es un nombre que se usa para identificar el contenido del mensaje. Un nodo que está interesado en cierto tipo de datos se suscribirá al tema apropiado. Puede haber varios editores y suscriptores simultáneos para un único tema, y un solo nodo puede publicar y / o suscribirse a múltiples temas. En general, los editores y los suscriptores no conocen la existencia de los demás. La idea es desacoplar la producción de información de su consumo. Lógicamente, uno puede pensar en un tema como un bus de mensajes fuertemente tipado. Cada autobús tiene un nombre, y cualquiera puede conectarse al autobús para enviar o recibir mensajes, siempre que sean del tipo correcto.

\subsection{Servicios}
El modelo de publicación / suscripción es un paradigma de comunicación muy flexible, pero su transporte unidireccional de muchos a muchos no es apropiado para las interacciones de solicitud / respuesta, que a menudo se requieren en un sistema distribuido. La solicitud / respuesta se realiza a través de servicios, que están definidos por un par de estructuras de mensaje: una para la solicitud y otra para la respuesta. Un nodo proveedor ofrece un servicio con un nombre y un cliente usa el servicio enviando el mensaje de solicitud y esperando la respuesta. Las bibliotecas cliente de ROS generalmente presentan esta interacción al programador como si fuera una llamada de procedimiento remoto.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{img/ros-architecture-3.jpg}
  	\caption{Arquitectura básica ROS publicación-suscripción}
  	\label{fig:ros-servicio}
\end{figure}
